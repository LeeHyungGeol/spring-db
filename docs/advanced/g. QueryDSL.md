# 6. 데이터 접근 기술 - QueryDSL<br/>## 목차- QueryDSL 이란?- QueryDSL 설정# 💡QueryDsl 이란?Querydsl은 정적 타입을 이용해서 SQL과 같은 쿼리를 생성할 수 있도록 해주는 라이브러리 입니다.  Querydsl은 쿼리를 type-safe하게 개발할 수 있게 지원하는 라이브러리로 주로 JPA Query ( JPQL )에서 사용합니다.DSL은 Domain Specific Language로 특정한 토메인에 초점을 맞춘 제한적인 표현력을 가진 컴퓨터 프로그래밍 언어로 단순하고, 간결합니다.이 DSL을 쿼리에 적용시켜 쿼리에 특화된 프로그래밍 언어로 제공한 것이 QueryDSL입니다.기존 방식에는 어떤 문제가 있었을까?<br/>## ⚡️ 기존 방식의 문제점Query를 직접 작성해야 하는 SQL Mapper 방식이나 JPA에서 JPQL을 사용해 Query가 잘못 작성되는 경우,  **컴파일 시점에서 체크가 불가능**하고 오직 런타임 시점에서 체크를 하기 때문에 개발자가 오류를 찾는데 어려움이 있었습니다.   이런 문제는 `type-safe 하지 않다`고 말합니다.`type-safe 하다` -> **컴파일 시점에서 문제를 잡을 수 있다.**## ⚡️ QueryDSL 로 해결QueryDSL 을 사용하면 쿼리를 메소드로 제어해서 컴파일 시점에서 쿼리의 오류를 잡아줄 수 있습니다.앞서 살펴본 Spring Data JPA에는 ( 동적인 쿼리에 대한 ) 조회에서 약점이 있었습니다.QueryDSL로 복잡한 조회 기능을 보완하고 그 외 단순한 경우는 Spring Data JPA를 사용합시다.주로, JPA 쿼리(JPQL)에 사용한다.## ⚡️ 작동 방식![image](https://github.com/jub3907/Spring-study/assets/58246682/a69eb821-af2c-4536-bbf1-2ed5d964b68a)<br/><br/>## ⚡️ 장단점Type-Safe하고, 단순하고, 쉽다는 장점이 있다.\다만, Q코드 생성을 위한 APT(Annotation Process Tool)를 \설정해야 한다는 단점이 존재한다.<br/><br/><br/># 💡 Querydsl 설정## ⚡️ build.gradle```groovydependencies {    //Querydsl 추가    implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'    annotationProcessor "com.querydsl:querydsl-apt:${dependencyManagement.importedProperties['querydsl.version']}:jakarta"    annotationProcessor "jakarta.annotation:jakarta.annotation-api"    annotationProcessor "jakarta.persistence:jakarta.persistence-api"}//Querydsl 추가, 자동 생성된 Q클래스 gradle clean으로 제거clean {    delete file('src/main/generated')}```## ⚡️ 검증 - Q 타입 생성 확인 방법`Preferences -> Build, Execution, Deployment -> Build Tools -> Gradle`![image](https://github.com/jub3907/Spring-study/assets/58246682/75772094-c9b9-4f42-b931-607780a9cccb)### 🔋 옵션 선택1 - Gradle - Q타입 생성 확인 방법* **Gradle IntelliJ 사용법**    * Gradle -> Tasks -> build -> clean    * Gradle -> Tasks -> other -> compileJava* **Gradle 콘솔 사용법**    * ./gradlew clean compileJava* Q 타입 생성 확인    * `build -> generated -> sources -> annotationProcessor -> java/main` 하위에 hello.itemservice.domain.QItem 이 생성되어 있어야 한다> 참고: Q타입은 컴파일 시점에 자동 생성되므로 버전관리(GIT)에 포함하지 않는 것이 좋다.  > gradle 옵션을 선택하면 Q타입은 gradle build 폴더 아래에 생성되기 때문에 여기를 포함하지 않아야 한다.   > 대부분 gradle build 폴더를 git에 포함하지 않기 때문에 이 부분은 자연스럽게 해결된다.<br/>### 🔋 Q타입 삭제gradle clean 을 수행하면 build 폴더 자체가 삭제된다.  따라서 별도의 설정은 없어도 된다.<br/>### 🔋 옵션 선택2 - IntelliJ IDEA - Q타입 생성 확인 방법- Build -> Build Project 또는 - Build -> Rebuild 또는- main() 또는- 테스트를 실행하면 된다.`src/main/generated` 하위에 `hello.itemservice.domain.QItem` 이 생성되어 있어야 한다.> 참고: Q타입은 컴파일 시점에 자동 생성되므로 버전관리(GIT)에 포함하지 않는 것이 좋다.> IntelliJ IDEA 옵션을 선택하면 Q타입은 `src/main/generated` 폴더 아래에 생성되기 때문에 여기를 포함하지 않는 것이 좋다.<br/>### 🔋 Q타입 삭제```java//Querydsl 추가, 자동 생성된 Q클래스 gradle clean으로 제거clean {    delete file('src/main/generated')}````IntelliJ IDEA` 옵션을 선택하면 `src/main/generated` 에 파일이 생성되고, 필요한 경우 Q파일을 직접 삭제해야 한다.`gradle` 에 해당 스크립트를 추가하면 `gradle clean` 명령어를 실행할 때 `src/main/generated` 의 파일도 함께 삭제해준다.<br/><br/><br/>## Querydsl 적용### JpaItemRepositoryV3```java@Repository@Transactionalpublic class JpaItemRepositoryV3 implements ItemRepository {    private final EntityManager em;    private final JPAQueryFactory query;    public JpaItemRepositoryV3(EntityManager em) {        this.em = em;        this.query = new JPAQueryFactory(em);    }    @Override    public Item save(Item item) {        em.persist(item);        return item;    }    @Override    public void update(Long itemId, ItemUpdateDto updateParam) {        Item findItem = em.find(Item.class, itemId);        findItem.setItemName(updateParam.getItemName());        findItem.setPrice(updateParam.getPrice());        findItem.setQuantity(updateParam.getQuantity());    }    @Override    public Optional<Item> findById(Long id) {        Item item = em.find(Item.class, id);        return Optional.ofNullable(item);    }    public List<Item> findAllOld(ItemSearchCond cond) {        String itemName = cond.getItemName();        Integer maxPrice = cond.getMaxPrice();//        QItem item = new QItem("i");        QItem item = QItem.item;        BooleanBuilder builder = new BooleanBuilder();        if (maxPrice != null) {            builder.and(item.price.loe(maxPrice));        }        List<Item> result = query                .select(item)                .from(item)                .where(builder)                .fetch();        return result;    }    @Override    public List<Item> findAll(ItemSearchCond cond) {        String itemName = cond.getItemName();        Integer maxPrice = cond.getMaxPrice();        return query.select(item)                .from(item)                .where(likeItemName(itemName), maxPrice(maxPrice))                .fetch();    }    private BooleanExpression maxPrice(Integer maxPrice) {        if (maxPrice != null) {            return item.price.loe(maxPrice);        }        return null;    }    private BooleanExpression likeItemName(String itemName) {        if (StringUtils.hasText(itemName)) {            return item.itemName.like("%" + itemName + "%");        }        return null;    }}```<br/>#### 공통Querydsl을 사용하려면 JPAQueryFactory 가 필요하다.\JPAQueryFactory 는 JPA 쿼리인 JPQL을 만들기 때문에 EntityManager 가 필요하다.설정 방식은 JdbcTemplate 을 설정하는 것과 유사하다.\참고로 JPAQueryFactory 를 스프링 빈으로 등록해서 사용해도 된다.<br/>#### save(), update(), findById()기본 기능들은 JPA가 제공하는 기본 기능을 사용한다<br/><br/>#### findAllOldQuerydsl을 사용해서 동적 쿼리 문제를 해결한다.\BooleanBuilder 를 사용해서 원하는 where 조건들을 넣어주면 된다.\이 모든 것을 자바 코드로 작성하기 때문에 동적 쿼리를 매우 편리하게 작성할 수 있다.<br/><br/>#### findAll앞서 findAllOld 에서 작성한 코드를 깔끔하게 리팩토링 했다. \다음 코드는 누가 봐도 쉽게 이해할 수 있을 것이다.```javaList<Item> result = query        .select(item)        .from(item)        .where(likeItemName(itemName), maxPrice(maxPrice))        .fetch();```Querydsl에서 where(A,B) 에 다양한 조건들을 직접 넣을 수 있는데, \이렇게 넣으면 AND 조건으로 처리된다. \참고로 where() 에 null 을 입력하면 해당 조건은 무시한다.이 코드의 또 다른 장점은 likeItemName() , maxPrice() 를 다른 쿼리를 \작성할 때 재사용 할 수 있다는 점이다. \쉽게 이야기해서 쿼리 조건을 부분적으로 모듈화 할 수 있다. \자바 코드로 개발하기 때문에 얻을 수 있는 큰 장점이다.이제 설정하고 실행해보자.<br/><br/>### QuerydslConfig```java@Configuration@RequiredArgsConstructorpublic class QuerydslConfig {    private final EntityManager em;    @Bean    public ItemService itemService() {        return new ItemServiceV1(itemRepository());    }    @Bean    public ItemRepository itemRepository() {        return new JpaItemRepositoryV3(em);    }}```<br/><br/>### ItemServiceApplication - 변경```java//@Import(SpringDataJpaConfig.class)@Import(QuerydslConfig.class)@SpringBootApplication(scanBasePackages = "hello.itemservice.web")public class ItemServiceApplication {}```QuerydslConfig 를 사용하도록 변경했다.<br/><br/>#### 예외 변환Querydsl 은 별도의 스프링 예외 추상화를 지원하지 않는다. \대신에 JPA에서 학습한 것 처럼 @Repository 에서 스프링 예외 추상화를 처리해준다.<br/><br/>## 정리### Querydsl 장점Querydsl 덕분에 동적 쿼리를 매우 깔끔하게 사용할 수 있다.```javaList<Item> result = query        .select(item)        .from(item)        .where(likeItemName(itemName), maxPrice(maxPrice))        .fetch();```쿼리 문장에 오타가 있어도 컴파일 시점에 오류를 막을 수 있다.\메서드 추출을 통해서 코드를 재사용할 수 있다. \예를 들어서 여기서 만든 likeItemName(itemName) , \maxPrice(maxPrice) 메서드를 다른 쿼리에서도 함께 사용할 수 있다.Querydsl을 사용해서 자바 코드로 쿼리를 작성하는 장점을 느껴보았을 것이다.\그리고 동적 쿼리 문제도 깔끔하게 해결해보았다.\Querydsl은 이 외에도 수 많은 편리한 기능을 제공한다. \예를 들어서 최적의 쿼리 결과를 만들기 위해서 DTO로 편리하게 조회하는 기능은 \실무에서 자주 사용하는 기능이다. JPA를 사용한다면 스프링 데이터 JPA와 \Querydsl은 실무의 다양한 문제를 편리하게 해결하기 위해 선택하는 기본 기술이라 생각한다.<br/><br/>